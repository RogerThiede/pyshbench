#!/usr/bin/python3
import subprocess
import re
import statistics
import math
import sys

def run(prog, runs):
	rlist = []
	exp = re.compile(b"Nodes/second\s*: (\d+)")
	for i in range(runs):
		cap = subprocess.Popen([prog,"bench"], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
		res = int(exp.search(cap.stderr.read()).group(1))
		print("%s %d: %d" % (prog,i+1,res))
		rlist.append(res)
	return rlist

def erf_inv(x):
	"""Inverse of math.erf()"""
	a = 8 * (math.pi - 3) / (3 * math.pi*(4 - math.pi))
	y = math.log(1 - x * x)
	z = 2 / (math.pi * a) + y / 2
	return math.copysign(math.sqrt(math.sqrt(z * z - y / a) - z), x)

def CDF(q):
	"""CDF of the standard Gaussian law"""
	return 0.5 * (1 + math.erf(q / math.sqrt(2)))

def Quantile(p):
	"""Quantile function of the standard Gaussian law"""
	assert(0 <= p and p <= 1)
	return math.sqrt(2)*erf_inv(2*p-1)

if (len(sys.argv) != 4 or int(sys.argv[3]) < 2):
	exit("Usage:\n" + sys.argv[0] + "test base #runs\nwhere #runs >= 2")

runs = int(sys.argv[3])

base = run(sys.argv[1], runs)
test = run(sys.argv[2], runs)
diff = [y - x for x, y in zip(base, test)]

base_mean = statistics.mean(base)
test_mean = statistics.mean(test)
diff_mean = statistics.mean(diff)

base_sdev = statistics.stdev(base, base_mean) / math.sqrt(runs)
test_sdev = statistics.stdev(test, test_mean) / math.sqrt(runs)
diff_sdev = statistics.stdev(diff, diff_mean) / math.sqrt(runs)

print("base: ", base_mean, "+/-", Quantile(0.975) * base_sdev)
print("test: ", test_mean, "+/-", Quantile(0.975) * test_sdev)
print("diff: ", diff_mean, "+/-", Quantile(0.975) * diff_sdev)
print("P(test > base) = ", CDF(diff_mean / diff_sdev))
