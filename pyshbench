#!/usr/bin/python3
import subprocess
import re
import statistics
import math
import sys

def CDF(q):
	"""CDF of the standard Gaussian law"""
	return 0.5 * (1 + math.erf(q / math.sqrt(2)))

if (len(sys.argv) != 4 or int(sys.argv[3]) < 2):
	exit("Usage:\n" + sys.argv[0] + "test base #runs\nwhere #runs >= 2")

base, test, diff = [], [], []
runs = int(sys.argv[3])
exp = re.compile(b"Nodes/second\s*: (\d+)")
print("run\tbase\ttest\tdiff")

for i in range(runs):
	# Start both processes. This is non-blocking.
	base_process = subprocess.Popen([sys.argv[1],"bench"], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
	test_process = subprocess.Popen([sys.argv[2],"bench"], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)

	# Wait for processes to finish and grep nps results in their stderr output
	base.append(int(exp.search(base_process.stderr.read()).group(1)))
	test.append(int(exp.search(test_process.stderr.read()).group(1)))

	diff.append(test[i] - base[i])
	print("%d\t%d\t%d\t%d" % (i + 1, base[i], test[i], diff[i]))

base_mean = statistics.mean(base)
test_mean = statistics.mean(test)
diff_mean = statistics.mean(diff)

base_sdev = statistics.stdev(base, base_mean) / math.sqrt(runs)
test_sdev = statistics.stdev(test, test_mean) / math.sqrt(runs)
diff_sdev = statistics.stdev(diff, diff_mean) / math.sqrt(runs)

print("\nbase = %d +/- %d" % (base_mean, 1.96 * test_sdev))
print("test = %d +/- %d" % (test_mean, 1.96 * test_sdev))
print("diff = %d +/- %d" % (diff_mean, 1.96 * diff_sdev))
print("\nspeedup = %.4f" % (diff_mean / base_mean))
print("P(speedup > 0) = %.4f" % CDF(diff_mean / diff_sdev))
